<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>C++ – Templates</title>
  <link rel="stylesheet" href="../../style.css">
  <style>
    .definition { padding: .75rem; border-left: 4px solid #2b7cff; background:#f3f8ff; border-radius:4px; margin: .75rem 0; }
    .satz { padding: .75rem; border-left: 4px solid #2b7cff; background:#f9f9fb; border-radius:4px; margin: .75rem 0; }
    .example { padding: .75rem; border-left: 4px solid #2e9a6a; background:#f4fffa; border-radius:4px; margin: .75rem 0; }
    .note { padding: .75rem; border-left: 4px solid #ff9800; background:#fff8f0; border-radius:4px; margin: .75rem 0; }
    .small { font-size:0.95rem; color:#444; }
    pre { background:#1e1e1e; color:#d4d4d4; padding:1rem; border-radius:4px; overflow-x:auto; font-size:0.95rem; }
    code { font-family: Consolas, monospace; }
  </style>
</head>

<body>

<nav>
  <a href="../../index.html">Startseite</a>
</nav>

<section>

<h1>Templates</h1>
<p class="small">
  Templates ermöglichen generischen Code in C++.  
  Funktionen und Klassen können unabhängig vom Datentyp definiert werden, um Wiederverwendbarkeit und Typsicherheit zu gewährleisten.
</p>

<h2>1. Funktions-Templates</h2>
<div class="definition">
  Ein Funktions-Template definiert eine generische Funktion, die mit beliebigen Typen arbeiten kann.
</div>

<div class="example">
  <pre><code>template &lt;typename T&gt;
T max(T a, T b) {
    return (a &gt; b) ? a : b;
}

int main() {
    std::cout &lt;&lt; max(3, 7) &lt;&lt; std::endl;       // int
    std::cout &lt;&lt; max(3.5, 2.1) &lt;&lt; std::endl; // double
    return 0;
}</code></pre>
</div>

<h2>2. Klassen-Templates</h2>
<div class="definition">
  Klassen-Templates definieren generische Klassen, die für unterschiedliche Datentypen instanziiert werden können.
</div>

<div class="example">
  <pre><code>template &lt;typename T&gt;
class Speicher {
private:
    T daten;
public:
    Speicher(T wert) : daten(wert) {}
    T get() { return daten; }
};

int main() {
    Speicher&lt;int&gt; si(42);
    Speicher&lt;double&gt; sd(3.14);

    std::cout &lt;&lt; si.get() &lt;&lt; std::endl;
    std::cout &lt;&lt; sd.get() &lt;&lt; std::endl;
    return 0;
}</code></pre>
</div>

<h2>3. Best Practices</h2>
<div class="definition">
  <ul>
    <li>Templates nur bei wirklich generischem Verhalten nutzen</li>
    <li>Code-Duplizierung vermeiden</li>
    <li>Vorwärtsdeklarationen beachten</li>
    <li>Komplexe Templates mit <code>typename</code> und <code>template</code> sauber dokumentieren</li>
  </ul>
</div>

<h2>4. Zusammenfassung</h2>
<ul>
  <li>Templates ermöglichen generischen Code</li>
  <li>Funktionen und Klassen können für beliebige Datentypen genutzt werden</li>
  <li>Verbessern Wiederverwendbarkeit und Typsicherheit</li>
</ul>

</section>

</body>
</html>